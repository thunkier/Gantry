using Gantry.Core.Domain.Collections;
using Gantry.Core.Domain.Http;
using Gantry.Core.Domain.Settings;
using System.Text;
using System.Text.Json;
using System.Text.Json.Nodes;

namespace Gantry.Infrastructure.Export;

public class OpenApiExporter : ICollectionExporter
{
    public string Name => "OpenAPI 3.0";
    public string Extension => "json";

    public Task<byte[]> ExportAsync(Collection collection)
    {
        // 1. Root Document Structure
        var root = new JsonObject
        {
            ["openapi"] = "3.0.1",
            ["info"] = new JsonObject
            {
                ["title"] = collection.Name,
                ["version"] = "1.0.0",
                ["description"] = "Generated by Gantry"
            },
            ["servers"] = new JsonArray(),
            ["paths"] = new JsonObject(),
            ["components"] = new JsonObject
            {
                ["securitySchemes"] = new JsonObject()
            }
        };

        // 2. Gather all requests (recursively)
        var allRequests = GetAllRequests(collection).ToList();

        // 3. Determine Global Servers (Host)
        // We take the host from the first valid URL we find as the primary server
        var primaryHost = ExtractPrimaryHost(allRequests);
        if (!string.IsNullOrEmpty(primaryHost))
        {
            root["servers"]!.AsArray().Add(new JsonObject { ["url"] = primaryHost });
        }

        // 4. Register Security Schemes (Auth)
        var usedAuthTypes = new HashSet<string>();
        RegisterSecuritySchemes(root["components"]!["securitySchemes"]!.AsObject(), allRequests, usedAuthTypes);

        // 5. Build Paths and Operations
        var paths = root["paths"]!.AsObject();

        foreach (var reqItem in allRequests)
        {
            if (!TryGetPathAndQuery(reqItem.Request.Url, primaryHost, out string path, out var queryParams))
            {
                // Fallback for invalid URLs
                path = "/";
            }

            // Ensure Path Item exists
            if (!paths.ContainsKey(path))
            {
                paths[path] = new JsonObject();
            }

            var pathItem = paths[path]!.AsObject();
            var method = reqItem.Request.Method.ToLower();

            // Build the Operation
            var operation = new JsonObject
            {
                ["summary"] = reqItem.Name,
                ["operationId"] = SanitizeOperationId($"{reqItem.Name}_{method}"),
                ["responses"] = new JsonObject
                {
                    ["200"] = new JsonObject { ["description"] = "Successful response" }
                }
            };

            // Add Parameters (Query & Headers)
            var parameters = new JsonArray();
            AddQueryParameters(parameters, queryParams);
            AddHeaderParameters(parameters, reqItem.Request.Headers);

            if (parameters.Count > 0)
            {
                operation["parameters"] = parameters;
            }

            // Add Request Body (if applicable)
            if (CanHaveBody(method) && !string.IsNullOrWhiteSpace(reqItem.Request.Body))
            {
                AddRequestBody(operation, reqItem.Request);
            }

            // Add Security Requirement
            AddSecurityRequirement(operation, reqItem.Auth, usedAuthTypes);

            // Assign operation to path
            pathItem[method] = operation;
        }

        var jsonString = root.ToJsonString(new JsonSerializerOptions { WriteIndented = true });
        return Task.FromResult(Encoding.UTF8.GetBytes(jsonString));
    }

    // --- Helpers ---

    private void AddRequestBody(JsonObject operation, RequestModel request)
    {
        var content = new JsonObject();
        var contentType = GetContentType(request);

        var mediaType = new JsonObject();

        // Infer schema if it is JSON
        if (contentType.Contains("json"))
        {
            try
            {
                var bodyNode = JsonNode.Parse(request.Body);
                if (bodyNode != null)
                {
                    mediaType["schema"] = InferSchema(bodyNode);
                }
            }
            catch
            {
                // Fallback for invalid JSON
                mediaType["schema"] = new JsonObject { ["type"] = "string" };
            }
        }
        else
        {
            mediaType["schema"] = new JsonObject { ["type"] = "string" };
        }

        content[contentType] = mediaType;
        operation["requestBody"] = new JsonObject
        {
            ["content"] = content
        };
    }

    private void AddSecurityRequirement(JsonObject operation, AuthSettings auth, HashSet<string> registeredSchemes)
    {
        if (auth.Type == AuthType.BearerToken && registeredSchemes.Contains("bearerAuth"))
        {
            operation["security"] = new JsonArray
            {
                new JsonObject { ["bearerAuth"] = new JsonArray() }
            };
        }
        else if (auth.Type == AuthType.Basic && registeredSchemes.Contains("basicAuth"))
        {
            operation["security"] = new JsonArray
            {
                new JsonObject { ["basicAuth"] = new JsonArray() }
            };
        }
    }

    private void RegisterSecuritySchemes(JsonObject schemesObj, List<RequestItem> requests, HashSet<string> usedAuthTypes)
    {
        bool hasBearer = requests.Any(r => r.Auth.Type == AuthType.BearerToken);
        bool hasBasic = requests.Any(r => r.Auth.Type == AuthType.Basic);

        if (hasBearer)
        {
            schemesObj["bearerAuth"] = new JsonObject
            {
                ["type"] = "http",
                ["scheme"] = "bearer"
            };
            usedAuthTypes.Add("bearerAuth");
        }

        if (hasBasic)
        {
            schemesObj["basicAuth"] = new JsonObject
            {
                ["type"] = "http",
                ["scheme"] = "basic"
            };
            usedAuthTypes.Add("basicAuth");
        }
    }

    private void AddQueryParameters(JsonArray parametersArray, System.Collections.Specialized.NameValueCollection query)
    {
        if (query == null) return;
        foreach (string key in query)
        {
            parametersArray.Add(new JsonObject
            {
                ["name"] = key,
                ["in"] = "query",
                ["schema"] = new JsonObject { ["type"] = "string", ["example"] = query[key] }
            });
        }
    }

    private void AddHeaderParameters(JsonArray parametersArray, Dictionary<string, string> headers)
    {
        if (headers == null) return;
        foreach (var kvp in headers)
        {
            // Skip Content-Type and Authorization as they are handled separately in OpenAPI
            if (kvp.Key.Equals("Content-Type", StringComparison.OrdinalIgnoreCase) ||
                kvp.Key.Equals("Authorization", StringComparison.OrdinalIgnoreCase))
                continue;

            parametersArray.Add(new JsonObject
            {
                ["name"] = kvp.Key,
                ["in"] = "header",
                ["schema"] = new JsonObject { ["type"] = "string", ["example"] = kvp.Value }
            });
        }
    }

    private JsonObject InferSchema(JsonNode node)
    {
        // Re-used logic from JsonSchemaExporter for brevity
        var schema = new JsonObject();
        switch (node)
        {
            case JsonObject obj:
                schema["type"] = "object";
                var props = new JsonObject();
                schema["properties"] = props;
                foreach (var p in obj) if (p.Value != null) props.Add(p.Key, InferSchema(p.Value));
                break;
            case JsonArray arr:
                schema["type"] = "array";
                schema["items"] = (arr.Count > 0 && arr[0] != null) ? InferSchema(arr[0]!) : new JsonObject { ["type"] = "string" };
                break;
            case JsonValue val:
                schema["type"] = val.TryGetValue<int>(out _) ? "integer" : val.TryGetValue<bool>(out _) ? "boolean" : "string";
                break;
            default:
                schema["type"] = "string";
                break;
        }
        return schema;
    }

    private bool TryGetPathAndQuery(string fullUrl, string primaryHost, out string path, out System.Collections.Specialized.NameValueCollection query)
    {
        path = "/";
        query = null;

        if (Uri.TryCreate(fullUrl, UriKind.Absolute, out var uri))
        {
            path = uri.AbsolutePath;
            query = System.Web.HttpUtility.ParseQueryString(uri.Query);
            return true;
        }

        // Handle variable-based URLs like {{baseUrl}}/users
        if (!string.IsNullOrEmpty(fullUrl))
        {
            // Naive split for simple cases if Uri parsing fails
            var parts = fullUrl.Split('?');
            path = parts[0];
            if (!string.IsNullOrEmpty(primaryHost) && path.StartsWith(primaryHost))
            {
                path = path.Substring(primaryHost.Length);
            }
            // Ensure leading slash
            if (!path.StartsWith("/") && !path.StartsWith("http")) path = "/" + path;

            return true;
        }

        return false;
    }

    private string ExtractPrimaryHost(List<RequestItem> requests)
    {
        var validUrl = requests.FirstOrDefault(r => Uri.IsWellFormedUriString(r.Request.Url, UriKind.Absolute))?.Request.Url;
        if (validUrl != null)
        {
            var uri = new Uri(validUrl);
            return $"{uri.Scheme}://{uri.Authority}";
        }
        return "";
    }

    private IEnumerable<RequestItem> GetAllRequests(Collection collection)
    {
        foreach (var r in collection.Requests) yield return r;
        foreach (var sub in collection.SubCollections)
            foreach (var r in GetAllRequests(sub)) yield return r;
    }

    private string SanitizeOperationId(string name) => System.Text.RegularExpressions.Regex.Replace(name, "[^a-zA-Z0-9]", "");

    private bool CanHaveBody(string method) => method == "post" || method == "put" || method == "patch";

    private string GetContentType(RequestModel req)
    {
        return req.Headers.FirstOrDefault(h => h.Key.Equals("Content-Type", StringComparison.OrdinalIgnoreCase)).Value ?? "application/json";
    }
}